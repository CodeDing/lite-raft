#!/bin/dash

#Copyright (c) 2014 Luigi Tarenga <luigi.tarenga@gmail.com>
#Distributed under the terms of a MIT license.

export sshopt="-o ConnectTimeout=1 -o ServerAliveInterval=2 \
-o ServerAliveCountMax=3 -o StrictHostKeyChecking=no \
-o ControlMaster=auto -o ControlPath=~/.ssh/master-%r@%h:%p"
cd $(dirname $0)

read server_role      < temp/server_role
read hostname         < temp/hostname
read current_leader   < temp/current_leader
read client_timeout   < conf/client_timeout
read cluster_nodes    < conf/cluster_nodes

#client-append-entry:
#input  command key value
#output term entry_index success

if ! flock -e -w 0 temp/master_lock true ; then
   if [ "$server_role" = "leader" ] ; then
      case "$1" in
      condset|set|unset|noop)
         {
            flock -e 9
            if [ "$1" = "condset" ] ; then
               read quorum_heartbeat < temp/quorum_heartbeat
               read commit_index     < temp/commit_index
               read last_log_index   < state/last_log_index
               if [ "$quorum_heartbeat" = "true" -a "$commit_index" -eq "$last_log_index" ] ; then
                  read val < state-machine-data/$2
                  if [ "$val" = "$3" ] ; then
                     set -- "set" "$2" "$4"
                  else
                     echo value of "$2" does not match "$3" >&2
                     echo 0 0
                     exit 1
                  fi
               else
                  echo leader is stale. try again >&2
                  echo 0 0
                  exit 1
               fi
            fi

            internals/client-append-entry "$@" > temp/client_result
            read term entry_index success < temp/client_result
         } 9> temp/activity_lock

         if [ "$success" = "true" ] ; then
            #inserted: wait for commit
            flock -e temp/activity_lock internals/leader
            read commit_index < temp/commit_index
            i=0
            while [ "$commit_index" -lt "$entry_index" -a "$i" -lt "$client_timeout" ] ; do
               sleep 1
               i=$(($i+1))
               read commit_index < temp/commit_index
            done

            if [ "$commit_index" -ge "$entry_index" -a -f state-machine-log/$entry_index/$term ] ; then
               echo client succeded >&2
               echo $term $entry_index
            else
               echo timeout waiting for commit >&2
               echo $term $entry_index
               exit 1
            fi
         else
            echo client failed to append new entry >&2
            echo 0 0
            exit 1
         fi
      ;;
      get)
         {
            flock -s 9
            read commit_index    < temp/commit_index
            read last_log_index   < state/last_log_index
            read quorum_heartbeat < temp/quorum_heartbeat
         } 9> temp/activity_lock
         if [ "$quorum_heartbeat" = "true" -a "$commit_index" -eq "$last_log_index" ] ; then
            #leader has still the quorum and everything is applied
            read val < state-machine-data/$2
            echo $val
         else
            echo leader is stale. try again >&2
            exit 1
         fi
      ;;
      status)
         echo Leader: $hostname
         for h in $cluster_nodes ; do
            [ "$h" = "$hostname" ] && continue
            read follower_timeout < temp/${h}_follower_timeout
            if [ "$follower_timeout" -gt 0 ] ; then
               echo Follower: $h
            else
               echo Unknown: $h
            fi
         done
      ;;
      esac

   elif [ -n "$current_leader" ] ; then
      ssh $sshopt "$current_leader" $PWD/$0 "$@"
   else
      echo leader is not yet ready
      exit 1
   fi
else
   #no process running here, return error
   echo no server running on $hostname. cannot process request.
   exit 1
fi
