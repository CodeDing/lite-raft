#!/bin/dash

#Copyright (c) 2014 Luigi Tarenga <luigi.tarenga@gmail.com>
#Distributed under the terms of a MIT license.

#
# this script should run on every node that can run a package.
# for each package an instance of package_controller is started on
# selected nodes. when this script detect that the tick of one
# package is not incrementing a race starts after $timeout+$pace*3
# seconds and the winner of the race set his own hostname as package
# owner. the package owner is responsible for starting the package
# and monitor it.
# the active node stop the package if not able to get/set values 
# on lite-raft after $timeout seconds.
#

PATH=$(dirname $0):$PATH
cd $(dirname $0)

package=$1
role="stand-by"

if [ -z "$package" ] ; then
   echo "Usage: ${0##*/} { package-name}"
   echo "This script should run "
   echo "  This is the cluster package monitor. It can run on multiple node and only"
   echo "  one switch from stand-by to active state activating the package and polling"
   echo "  its health status. "
   echo "  Usually it's started with the \"pkg start <packag-name>\" command."
   exit 0
fi

if [ -f temp/monitor_lock_$1 ] ; then
   if ! flock -e -w 0 temp/monitor_lock_$1 true ; then
      echo temp/monitor_lock_$1 is locked. cannot start pkg-mon.
      exit 1
   fi
fi

pace=4
for key in timeout tick owner ; do
   echo -n "$(date) reading package $key"
   while ! val=$(lite-raft-remote get packages/$package/$key) ; do
      echo -n .
      sleep $pace
   done
   #create a new variable with the name of $key and value of $val
   eval $key=\"$val\"
   echo " done."
done

counter=$(($timeout+$pace*3))
if [ "$owner" = "$HOSTNAME" ] ; then
   if lite-raft-remote if packages/$package/owner = "$HOSTNAME" set "" ; then
      #echo "$(date) resetting owner and cheating to win the race!"
      counter=0
      owner=""
   fi
fi

last_owner="$owner"
last_tick=$tick
stop="false"
pkg_state="unknown"

#trap 'stop="true"' HUP INT TERM
trap 'echo "$(date) received signal SIGHUP. starting halt sequence." ; stop="true"' HUP
trap 'echo "$(date) received signal SIGINT. starting halt sequence." ; stop="true"' INT
trap 'echo "$(date) received signal SIGTERM. starting halt sequence." ; stop="true"' TERM
trap '' USR1

quit () {
   fuser -s -k -TERM ~/.ssh/lite-raft-socket-*
   exit $1
}

{
   flock -e 9

   echo "$(date) starting as stand-by node." & sleep_pid=$!
   while true ; do
      wait $sleep_pid ; sleep $pace & sleep_pid=$!
      case $role in
       stand-by)
         [ "$stop" = "true" ] && quit 0

         tick=$(lite-raft-remote get packages/$package/tick) || continue
         if [ $tick -gt $last_tick ] ; then
            #tick incremented, there must be an active package-controler
            #pace*3 is a safety misure to let active node to shutdown package
            counter=$(($timeout+$pace*3))
            last_tick=$tick
            continue
         fi

         counter=$(($counter-$pace))
         last_tick=$tick

         #if cannot read owner loop again
         owner=$(lite-raft-remote get packages/$package/owner) || continue
         if [ "$owner" != "$last_owner" ] ; then
            counter=$(($timeout+$pace*3))
            last_owner="$owner"
            continue
         fi

         if [ $counter -le 0 ] ; then
            echo "$(date) tick timeout. trying to activate package."
            if lite-raft-remote if packages/$package/tick = $tick set $(($tick+1)) ; then
               tick=$(($tick+1))
               if lite-raft-remote if packages/$package/owner = "$last_owner" set "$HOSTNAME" ; then
                  echo "$(date) race won. turning to active node."
                  echo "$(date) package state starts as  $pkg_state."
                  lite-raft-remote set packages/$package/state $pkg_state
                  role="active"
                  counter=$timeout
               fi
            fi
         fi
       ;;

       active)
         if lite-raft-remote set packages/$package/tick $(($tick+1)) ; then
            counter=$timeout
            tick=$(($tick+1))
         else
            counter=$(($counter-$pace))
            [ $counter -le 0 ] && stop="true"
         fi

         if owner=$(lite-raft-remote get packages/$package/owner) ; then
            if [ "$owner" != "$HOSTNAME" ] ; then
               #this case should never happens. if it happens than 
               #there is a serious bug in pkg-mon implementation!
               #make the other owner fail too!
               lite-raft-remote set packages/$package/owner ""
               echo "$(date) BUG: found $owner as second active node!"
               stop="true"
            fi
         fi

         old_state=$pkg_state
         #handle all cases of the package state machine
         case $pkg_state in
          starting)
            if ! pkill -0 -x -f "$shell_cmd control-scripts/$package start" ; then
               wait $start_pid
               if [ $? -eq 0 ] ; then
                  pkg_state="running"
               else
                  pkg_state="failing"
               fi
            else
               start_timeout=$(($start_timeout-$pace))
            fi

            if [ $start_timeout -le 0 ] ; then
               echo "$(date) timeout waiting for package to start."
               pkill -x -f "$shell_cmd control-scripts/$package start"
               control-scripts/$package stop >> message-log/$package.log &
               stop_pid=$!
               pkg_state="failing"
            fi
          ;;

          running)
            #status function returns: 0 up, 1 down, 2 degraded
            control-scripts/$package status >> message-log/$package.log 
            pkg_status=$?
            if [ "$stop" = "true" ] ; then
               control-scripts/$package stop >> message-log/$package.log &
               pkg_state="halting"
            elif [ $pkg_status -ne 0 ] ; then
               control-scripts/$package stop >> message-log/$package.log &
               pkg_state="failing"
            fi
          ;;

          halting|failing)
            if ! pkill -0 -x -f "$shell_cmd control-scripts/$package stop" ; then
               wait $stop_pid
               if [ $? -eq 0 ] ; then
                  [ "$pkg_state" = "halting" ] && pkg_state="halted"
                  [ "$pkg_state" = "failing" ] && pkg_state="failed"
               else
                  pkg_state="failed"
               fi
            else
               stop_timeout=$(($stop_timeout-$pace))
            fi

            if [ $stop_timeout -le 0 ] ; then
               echo "$(date) timeout waiting for package to stop."
               #pkill -x -f "$shell_cmd control-scripts/$package stop"
               pkg_state="failed"
            fi
          ;;

          halted|failed)
               echo "$(date) package $pkg_state. exit."
               [ "$pkg_state" = "halted" ] && ret=0
               [ "$pkg_state" = "failed" ] && ret=1
               quit $ret
          ;;

          unknown)
            shell_cmd=$(head -1 control-scripts/$package)
            shell_cmd=${shell_cmd#\#!}

            if pkill -0 -x -f "$shell_cmd control-scripts/$package stop" ; then
               echo "$(date) start script already running. package state is unknown."
               quit 1
            fi

            if pkill -0 -x -f "$shell_cmd control-scripts/$package stop" ; then
               echo "$(date) stop script already running. package state is unknown."
               quit 1
            fi

            start_timeout=$(control-scripts/$package echo start_timeout)
            start_timeout=${start_timeout:-60}
            stop_timeout=$(control-scripts/$package echo stop_timeout)
            stop_timeout=${stop_timeout:-60}

            control-scripts/$package status >> message-log/$package.log 
            pkg_status=$?
            if [ "$stop" = "false" -a $pkg_status -eq 1 ] ; then
               control-scripts/$package start >> message-log/$package.log &
               start_pid=$!
               pkg_state="starting"
            else
               control-scripts/$package stop >> message-log/$package.log &
               stop_pid=$!
               pkg_state="failing"
            fi 
          ;;
         esac # package_state

         if [ "$old_state" != "$pkg_state" ] ; then
            echo "$(date) package state changes to $pkg_state."
            lite-raft-remote set packages/$package/state $pkg_state
         fi
       ;;
      esac # role
   done
} 9> temp/monitor_lock_$1
